## Содержание

| №   | Вопрос                                                                                                                                         |
|-----|------------------------------------------------------------------------------------------------------------------------------------------------|
| 1   | [Объектная модель Git: Blob, Tree, Commit, Tag?](#объектная-модель-git-blob-tree-commit-tag)                                                  |
| 2   | [Что такое "The Three Trees"?](#что-такое-the-three-trees-the-head-the-index-the-working-directory)                                          |
| 3   | [Как производить отмену изменений? Где какой способ стоит применять?](#как-производить-отмену-изменений-где-какой-способ-стоит-применять)                                          |
| 4   | [Stash,Reflog,Bisect](#что-делают-как-пользоваться-и-когда-бывают-полезны-команды)                                          |
| 5   | [Merge](#merge)                                          |

---

# Объектная модель Git: Blob, Tree, Commit, Tag?

Git хранит данные в виде набора объектов. Основные типы объектов:  
**Blob**, **Tree**, **Commit**, **Tag**.

### 1. **Blob (Binary Large Object)**

- Представляет **содержимое файла** (например, текст, изображение, код).  
- **Не содержит имени файла** или других метаданных — только **сырые данные**.
- Идентифицируется по **SHA-1-хэшу** содержимого (например, `d670460b4b4aece5915caf5c68d12f560a9fe3e4`).
- Не имеет связей с другими объектами — **конечная точка**.
- Если несколько деревьев ссылаются на один и тот же blob, это аналог **жёсткой ссылки**:  
  объект не будет удалён, пока на него ссылается хотя бы один элемент дерева.

#### Пример:
Если вы создаёте файл `hello.txt` с текстом `Hello, World!`, Git сохранит его содержимое как blob.

#### Как посмотреть:
```bash
git hash-object hello.txt         # Получить хэш blob
git cat-file -p <хэш>            # Показать содержимое blob
git ls-tree HEAD                 # Просмотреть дерево, содержащее файл
```
Если два файла имеют одинаковое содержимое, они будут представлены одним и тем же blob-объектом. Это позволяет Git эффективно хранить несколько копий одного и того же файла.

### 2. **Tree**

Tree содержит список объектов blob и других tree, представляющих файлы и поддиректории внутри этой директории.

- **Содержание**: Список записей, где каждая запись состоит из:
  - Режима (права доступа, тип файла)
  - Имени файла или директории
  - SHA-1 хеша объекта `blob` или `tree`, представляющего файл или поддиректорию

### 3. **Commit (Коммит)**

Снимок состояния репозитория в определенный момент времени.

- **Содержание**: Идентификатор Tree:* Указывает на корневой Tree-объект для этого коммита:
  - SHA-1 хеш корневого tree (представляет состояние всего репозитория).
  - SHA-1 хеши родительских коммитов (один или несколько, для merge commits).
  - Информацию об авторе (имя, email, дата).
  - Информацию о коммиттере (имя, email, дата).
  - Сообщение коммита.

- **Связи**: Commit ссылается на:
  - Tree (через его идентификатор).
  - Parent Commit(s) (через их идентификаторы).
  - Идентификатор: SHA-1 хэш содержимого коммита.

### 4. **Tag (Метка)**

 Именованная ссылку на конкретный коммит (имя коммита).

- **Содержание**:
  - Аннотированный тег (Annotated Tag): Содержит SHA-1 хеш коммита, на который указывает тег, имя тега, информацию об авторе и сообщение. Это полноценный объект Git.
  - Облегченный тег (Lightweight Tag): Просто содержит SHA-1 хеш коммита. Это просто указатель на коммит, не является отдельным объектом Git.
  - Идентификация: Аннотированный тег идентифицируется по SHA-1 хешу своего содержимого. Облегченный тег не является объектом, и идентифицируется как ветка.
  - Роль: Позволяет легко ссылаться на определенные моменты в истории (например, релизы).
  - Связи: Tag ссылается на другой объект (обычно Commit). Аннотированный тег является отдельным объектом.

### Как это работает

1. Когда добавляются файлы в Git, он создаёт **Blob-объекты** для содержимого этих файлов.  
   Если файл уже существует и содержимое не изменилось, существующий Blob-объект будет повторно использован.

2. Когда изменения коммитятся, Git создаёт **Tree-объект**, который представляет структуру каталогов.  
   Этот Tree содержит записи, указывающие на **Blob-объекты** (файлы) и другие **Tree-объекты** (подкаталоги).

3. Затем Git создаёт **Commit-объект**, который:
   - указывает на корневой Tree-объект,
   - содержит информацию о коммиттере,
   - включает сообщение коммита,
   - содержит ссылки на родительские коммиты (если есть).

4. **Ветки (branches)** — это просто указатели на коммиты.  
   Когда создается новая ветка, создается новый указатель, указывающий на текущий коммит.

5. Когда вы делаете новый коммит в ветке, **указатель ветки перемещается** на новый коммит.

# Что такое "The Three Trees" (The HEAD, The Index, The Working Directory)?

### Что такое HEAD?

`HEAD` — это указатель на **текущий коммит**, обычно — на **последний коммит текущей ветки**.
Представляет историю проекта. Он служит основой для новых коммитов. Когда вы создаете новый коммит, он берет за основу состояние, на которое указывает HEAD.  Содержит метаданные о коммите (автор, дата, сообщение) и, что более важно, **полный снимок всех файлов и директорий, которые были в этом коммите**. Он хранит сжатые версии файлов.

### Detached HEAD

**Detached HEAD** — состояние, при котором `HEAD` указывает **не на ветку**, а **непосредственно на коммит**.  
Вы оказываетесь вне какой-либо ветки, в "безымянной" ветке.

#### Примеры:
- Переключение на коммит:
  ```bash
  git checkout <commit-hash>
  ```
 HEAD отсоединится и будет указывать непосредственно на этот коммит.

- Переключение на удалённую ветку без создания локальной:
  ```bash
  git checkout origin/main
  ```
  ---

  ### Проверка состояния HEAD
```bash
git symbolic-ref HEAD
```
- Если `HEAD` указывает на ветку — покажет путь, например: `refs/heads/main`.
- Если `HEAD` **detached** — будет ошибка:
  ```
  fatal: ref HEAD is not a symbolic ref
  ```

## Перемещения относительно HEAD

Эти обозначения позволяют перемещаться по истории коммитов:

- `HEAD^` — родитель коммита (первый родитель).
- `HEAD^^` — родитель родителя.
- `HEAD~n` — `n` поколений назад по **первой родительской линии**.  
  - `HEAD~` = `HEAD~1` = `HEAD^`.
  - `HEAD~2` = два поколения назад.

> ⚠️ Разница между `^` и `~` проявляется при работе с merge-коммитами:
> - `HEAD^2` — второй родитель merge-коммита.
> - `HEAD~2` — два коммита назад по **первому** родителю.

#### Пример:
```
    D
   / \
  B   A
 /     \
B2     A2
 \     /
  \   /
    C (HEAD)
```
- `git checkout HEAD~2` → переключение на `B` (по первой родительской линии).
- `git checkout HEAD^2` → переключение на `A2`.
- `git checkout HEAD^3` → ❌ ошибка (у коммита только 2 родителя).

---

## HEAD@{n} и reflog

- `HEAD@{n}` — доступ к истории перемещений `HEAD` через **reflog**.
- `HEAD@{0}` — текущее состояние `HEAD`.
- `HEAD@{1}` — предыдущее состояние.
- `HEAD@{2}` — два перемещения назад, и т.д.

> ⚠️ Обязательно указывать в кавычках:
> ```bash
> git checkout "HEAD@{1}"
> ```

`Reflog` позволяет вернуть `HEAD` к прежнему состоянию, даже если коммиты не сохранены в ветках.

---

## Области в Git

### 1. The Index (Индекс / Staging Area / Область Подготовки)

- Промежуточная зона между **рабочим каталогом** и **репозиторием Git**.
- Отслеживает, какие изменения пойдут в **следующий коммит**.
- Позволяет **выборочно** добавлять изменения:
  ```bash
  git add <файл>
  ```
- Хранит информацию об изменённых, добавленных и удалённых файлах.

---

### 2. The Working Directory (Рабочий Каталог)

- Это **реальная папка проекта**, где вы редактируете файлы.
- Git **не отслеживает автоматически** изменения в этой области.
- Чтобы сохранить изменения в истории Git:
  1. Добавьте их в **index**:  
     ```bash
     git add <файл>
     ```
  2. Затем сделайте **commit**:
     ```bash
     git commit -m "Сообщение"
     ```


# Как производить отмену изменений? Где какой способ стоит применять?

## 1. commit с флагом --amend

- Берет текущие изменения в staging area (индексе) и объединяет их с последним коммитом.
- Заменяет старый коммит новым коммитом, содержащим обновленное состояние.

### Когда использовать:

- Исправление незначительных ошибок в последнем коммите:  
  Типичные случаи — исправление опечаток в сообщении, добавление забытых файлов или мелкие правки, обнаруженные сразу после коммита.
- Улучшение последнего коммита.
- Когда коммит ещё не был опубликован (не сделан push).
- Объединение нескольких незначительных изменений в один коммит с помощью `--no-edit`.

**Важно!**  
НИКОГДА не используйте `--amend` для коммитов, которые уже были отправлены (pushed) в удалённый репозиторий, к которому имеют доступ другие разработчики.

---

## 2. Cherry-Pick

Позволяет выбрать и применить отдельные коммиты из одной ветки в другую.  
Берёт изменения, внесённые в указанном коммите, и пытается применить их к текущей ветке.

### Когда использовать:

- Если есть коммит с исправлением ошибки или новой фичей в ветке A1, и нужно внести это в ветку develop без слияния всей ветки A1.
- Исправление ошибок в разных ветках: можно выбрать коммит с исправлением из ветки hotfix и применить его в develop.
- Восстановление случайно утерянных изменений.  
  Можно применить с флагом `-n` или `--no-commit`, чтобы применить изменения без создания коммита.

---

## 3. git filter-branch и git-filter-repo

Обе утилиты предназначены для переписывания истории Git-репозитория —  
удаления чувствительной информации, реструктурирования репозитория и других сложных операций.

### git filter-branch

- Устаревший инструмент, встроенный в Git.
- Медленный и сложный, особенно на больших репозиториях.
- Опасный — легко допустить ошибку, которая повредит репозиторий.
- Работает путём перебора каждого коммита и запуска указанного фильтра.
- Создаёт новые коммиты и переписывает ветки.

### git-filter-repo

- Современная, рекомендуемая замена `git filter-branch`.
- Требует отдельной установки (обычно через `pip install git-filter-repo`).
- Быстрый и эффективный, с оптимизациями для больших репозиториев.
- Более безопасный и простой в использовании.
- Предлагает широкий набор фильтров и опций.

### Фильтры:

- `--path <путь>` — сохраняет только коммиты, затрагивающие указанный путь.
- `--invert-path` — сохраняет только коммиты, не затрагивающие указанный путь.

**Важно:** При переписывании истории создаются *новые* коммиты, старые остаются, но не отображаются по умолчанию.

---

## 4. git rebase

Перемещает последовательность коммитов на новую базу.  
Альтернатива `git merge` для интеграции изменений из одной ветки в другую.

Пример:  
Есть основная ветка (main или develop) и ветка feature. Пока вы работали над feature, в основную ветку добавились новые коммиты.  
`git rebase` позволяет "пересадить" feature на вершину основной ветки.

> Rebase теряет информацию о слияниях. Если нужно сохранить историю слияний — лучше использовать `git merge`.

---

### Интерактивный режим ребейза (`git rebase -i <база>`)

Позволяет переписать историю коммитов, делая её чище и удобнее.

- `<база>` — коммит, на который будут перенесены текущие коммиты.
- Позволяет контролировать каждый коммит: переупорядочивать, объединять, удалять, редактировать и пр.

### Основные команды интерактивного ребейза:

- `pick` — использовать коммит как есть.
- `reorder` — изменить порядок коммитов.
- `squash` / `fixup` — объединить коммиты в один.
- `drop` — удалить коммит.
- `edit` — отредактировать коммит.
- `reword` — изменить сообщение коммита.
- `exec` — выполнить команду.
- `split` — разделить коммит.

После запуска откроется редактор с инструкциями и списком коммитов.

---

### Опасности и рекомендации при использовании `git rebase`

- Ребейз изменяет историю — не делать на ветках, которые уже были опубликованы.
- Возможна потеря коммитов.
- Конфликты слияния могут быть сложными.
- Ребейз игнорирует информацию о слияниях.
- Используйте ребейз только на локальных, непубликуемых ветках.
- Делайте резервные копии веток перед ребейзом (новая ветка или тег).
- Для отката используйте:  
  ```bash
  git reset --hard <имя_тега>

# Что делают, как пользоваться, и когда бывают полезны команды:

## 1. git stash

Команда Git, которая временно сохраняет (stash) изменения в рабочей директории и индексе (staging area), которые еще не коммитили.  
Это как "отложить" работу, чтобы вернуться к ней позже.

Например, вы работаете над задачей и внезапно нужно переключиться на другую — вместо создания нового коммита можно использовать `git stash`.

Можно добавить сообщение к stash, как к коммиту.

### Основные команды:
```bash
git stash                     # Сохраняет текущие изменения
git stash list                # Показывает список сохранённых stash
git stash apply stash@{<номер>}  # Применяет конкретный stash
git stash apply               # Применяет последний stash (stash@{0})
git stash pop stash@{<номер>}     # Применяет и удаляет конкретный stash
git stash pop                # Применяет и удаляет последний stash (stash@{0})
git stash drop stash@{<номер>}    # Удаляет конкретный stash
git stash clear              # Удаляет все stash-и
```

Для сохранения неотслеживаемых файлов можно использовать:

``` bash
git stash save -u
```

### 2. git reflog

Команда, которая записывает историю изменений указателя HEAD и указателей веток в локальном репозитории.
Это "история перемещений" HEAD: коммиты, переключения веток, reset, merges, rebase.

**Важно**: reflog локален и не отправляется на удалённый репозиторий.

### Как пользоваться:
```bash
git reflog                    # Показать историю изменений HEAD
git reflog show <ветка>       # reflog конкретной ветки
git reset --hard <хэш_коммита_из_reflog>  # Возврат к коммиту из reflog (опасно, потеря данных)
```

### Когда использовать:
 - Восстановление потерянных коммитов (например, после удаления ветки или reset --hard).
 - Отмена ошибок (например, неправильный rebase)..
 - Отслеживание изменений в локальном репозитории.

> ⚠️ Важно:
> reflog хранится по умолчанию 90 дней, потом старые записи удаляются.

### 2. git besic

Инструмент для поиска коммита, который вызвал баг, с помощью двоичного поиска по истории.

### Как пользоваться:
```bash
git bisect start             # Запуск bisect
git bisect bad               # Отметить текущий коммит как "плохой"
git bisect good <хэш_коммита> # Отметить известный "хороший" коммит
# Далее Git переключится на коммит посередине
# Проверяете коммит и отмечаете:
git bisect good              # если баг отсутствует
git bisect bad               # если баг есть
git bisect reset             # Завершение bisect
```

### Когда использовать:
 - Быстрый поиск коммита с багом.
 - Значительно ускоряет процесс по сравнению с ручным поиском.
 - Можно автоматизировать с помощью скриптов (например, тестов).

 ## Недостатки:
 - Нужно знать "хороший" коммит.
 - Может быть сложным, если проверка багов занимает много времени.
 - Предполагает, что баг вызван одним коммитом — если взаимодействие нескольких коммитов, поиск может быть неточным.
 
 ---

 # Merge

 ### 1. Как отменить Merge Commit?

 #### Если коммит **ещё не запушен**:
```bash
git reset --hard HEAD^
```
Это удалит merge commit и все изменения, внесённые с ним.
⚠️ Все незафиксированные изменения будут потеряны. Альтернатива — --mixed.

#### Если коммит уже запушен:

```bash
git revert -m 1 <merge_commit_hash>
```

Создаст новый коммит, который отменит изменения, внесённые в merge commit.
Флаг -m 1 указывает, какой из родителей коммита выбрать в качестве основной ветки.

 ### 2. Что такое Fast-Forward Merge?

**Fast-Forward Merge (FF Merge)** — это тип слияния в Git, который происходит, когда ветка, в которую сливаются изменения,
является прямым потомком ветки, из которой сливают.

Fast-forward merge возможен только тогда, когда:

1. Вы находитесь в ветке, в которую хотите слить изменения (например, `main`).
2. Эта ветка **не имеет новых коммитов**, которых нет в ветке, которую сливаете.

#### Пример:

```
A -- B -- C (main)
          \  
           D -- E (feature/new-button)
```

Ветка `main` и `feature/new-button` разошлись в точке `C`. Коммиты `D` и `E` были добавлены только в `feature/new-button`.

Если переключиться на ветку `main` и выполнить:
```bash
git merge feature/new-button
```
Git обнаружит, что все коммиты в ветке main (`A`, `B`, `C`) уже есть в истории ветки `feature/new-button` (`A`, `B`, `C`, `D`, `E`).

Git **просто переместит указатель `main` на последний коммит в `feature/new-button` (коммит `E`)**:
```
A -- B -- C -- D -- E (main, feature/new-button)
```
### Ключевые особенности Fast-Forward Merge:

- ✅ Не создаёт merge commit
- ✅ Чистая история
- ✅ Отсутствие конфликтов

---

## Как предотвратить Fast-Forward Merge (`--no-ff`)

Иногда может понадобиться **предотвратить fast-forward merge**, даже если он возможен.  
Для этого используется флаг:

```bash
git merge --no-ff <ветка>
```

Git **всегда создаст merge commit**, даже если возможно fast-forward слияние.

---

## `--squash`: Слияние с «уплотнением» коммитов
Флаг `--squash`, используемый с командой `git merge`, применяет все изменения из целевой ветки,  
но **не создаёт merge commit** и **не сохраняет историю коммитов** из неё.
```bash
git merge --squash <ветка>
```
### Пример сценария:

Допустим, вы находитесь в `main`, и хотите подтянуть в неё изменения:

```bash
git merge --squash feature/login
git commit -m "Добавлен функционал логина"
```
---

### Ключевые особенности `--squash`:

- ✅ Не создаёт merge commit
- ✅ Объединяет несколько коммитов из ветки в **один**
- ✅ Требует ручного коммита

---

### Преимущества:

- ✅ Чистая история коммитов
- ✅ Контроль над сообщением коммита
- ✅ Упрощает откат изменений

---

### Недостатки:

- ⚠️ Потеря промежуточной истории коммитов
- ⚠️ Необходимость ручного коммита
- ⚠️ Сложнее отслеживать происхождение изменений




